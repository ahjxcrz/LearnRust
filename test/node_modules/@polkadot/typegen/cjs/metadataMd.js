"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.main = main;
var _fs = _interopRequireDefault(require("fs"));
var _types = require("@polkadot/types");
var definitions = _interopRequireWildcard(require("@polkadot/types/cjs/interfaces/definitions"));
var _getStorage = require("@polkadot/types/cjs/metadata/decorate/storage/getStorage");
var _StorageKey = require("@polkadot/types/cjs/primitive/StorageKey");
var _staticSubstrate = _interopRequireDefault(require("@polkadot/types-support/cjs/metadata/static-substrate"));
var _util = require("@polkadot/util");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// Copyright 2017-2023 @polkadot/typegen authors & contributors
// SPDX-License-Identifier: Apache-2.0

const STATIC_TEXT = '\n\n(NOTE: These were generated from a static/snapshot view of a recent Substrate master node. Some items may not be available in older nodes, or in any customized implementations.)';
const DESC_CONSTANTS = `The following sections contain the module constants, also known as parameter types. These can only be changed as part of a runtime upgrade. On the api, these are exposed via \`api.consts.<module>.<method>\`. ${STATIC_TEXT}`;
const DESC_EXTRINSICS = `The following sections contain Extrinsics methods are part of the default Substrate runtime. On the api, these are exposed via \`api.tx.<module>.<method>\`. ${STATIC_TEXT}`;
const DESC_ERRORS = `This page lists the errors that can be encountered in the different modules. ${STATIC_TEXT}`;
const DESC_EVENTS = `Events are emitted for certain operations on the runtime. The following sections describe the events that are part of the default Substrate runtime. ${STATIC_TEXT}`;
const DESC_RPC = 'The following sections contain known RPC methods that may be available on specific nodes (depending on configuration and available pallets) and allow you to interact with the actual node, query, and submit.';
const DESC_RUNTIME = 'The following section contains known runtime calls that may be available on specific runtimes (depending on configuration and available pallets). These call directly into the WASM runtime for queries and operations.';
const DESC_STORAGE = `The following sections contain Storage methods are part of the default Substrate runtime. On the api, these are exposed via \`api.query.<module>.<method>\`. ${STATIC_TEXT}`;

/** @internal */
function docsVecToMarkdown(docLines) {
  let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const md = docLines.map(docLine => docLine.toString().trimStart().replace(/^r"/g, '').trimStart()).reduce((md, docLine) =>
  // generate paragraphs
  !docLine.length ? `${md}\n\n` // empty line
  : /^[*-]/.test(docLine.trimStart()) && !md.endsWith('\n\n') ? `${md}\n\n${docLine}` // line calling for a preceding linebreak
  : `${md} ${docLine.replace(/^#{1,3} /, '#### ')} `, '').replace(/#### <weight>/g, '<weight>').replace(/<weight>(.|\n)*?<\/weight>/g, '').replace(/#### Weight:/g, 'Weight:');

  // prefix each line with indentation
  return md && md.split('\n\n').map(line => `${' '.repeat(indent)}${line}`).join('\n\n');
}
function renderPage(page) {
  let md = `---\ntitle: ${page.title}\n---\n\n`;
  if (page.description) {
    md += `${page.description}\n\n`;
  }

  // index
  page.sections.forEach(section => {
    md += `- **[${(0, _util.stringCamelCase)(section.name)}](#${(0, _util.stringCamelCase)(section.name).toLowerCase()})**\n\n`;
  });

  // contents
  page.sections.forEach(section => {
    md += '\n___\n\n\n';
    md += section.link ? `<h2 id="#${section.link}">${section.name}</h2>\n` : `## ${section.name}\n`;
    if (section.description) {
      md += `\n_${section.description}_\n`;
    }
    section.items.forEach(item => {
      md += ' \n';
      md += item.link ? `<h3 id="#${item.link}">${item.name}</h3>` : `### ${item.name}`;
      Object.keys(item).filter(key => !['link', 'name'].includes(key)).forEach(bullet => {
        md += `\n- **${bullet}**: ${
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        item[bullet] instanceof _types.Vec ? docsVecToMarkdown(item[bullet], 2).toString() : item[bullet]}`;
      });
      md += '\n';
    });
  });
  return md;
}
function sortByName(a, b) {
  // case insensitive (all-uppercase) sorting
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access
  return a.name.toString().toUpperCase().localeCompare(b.name.toString().toUpperCase());
}
function getSiName(lookup, type) {
  const typeDef = lookup.getTypeDef(type);
  return typeDef.lookupName || typeDef.type;
}

/** @internal */
function addRpc() {
  const sections = Object.keys(definitions).filter(key => Object.keys(definitions[key].rpc || {}).length !== 0);
  return renderPage({
    description: DESC_RPC,
    sections: sections.sort().reduce((all, _sectionName) => {
      const section = definitions[_sectionName];
      Object.keys(section.rpc || {}).sort().forEach(methodName => {
        const method = (section.rpc || {})[methodName];
        const sectionName = method.aliasSection || _sectionName;
        const topName = method.aliasSection ? `${_sectionName}/${method.aliasSection}` : _sectionName;
        let container = all.find(_ref => {
          let {
            name
          } = _ref;
          return name === topName;
        });
        if (!container) {
          container = {
            items: [],
            name: topName
          };
          all.push(container);
        }
        const args = method.params.map(_ref2 => {
          let {
            isOptional,
            name,
            type
          } = _ref2;
          // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
          return name + (isOptional ? '?' : '') + ': `' + type + '`';
        }).join(', ');
        const type = '`' + method.type + '`';
        const jsonrpc = method.endpoint || `${sectionName}_${methodName}`;
        const item = {
          interface: '`' + `api.rpc.${sectionName}.${methodName}` + '`',
          jsonrpc: '`' + jsonrpc + '`',
          // link: jsonrpc,
          name: `${methodName}(${args}): ${type}`,
          ...(method.description && {
            summary: method.description
          })
        };
        if (method.deprecated) {
          item.deprecated = method.deprecated;
        }
        container.items.push(item);
      });
      return all;
    }, []).sort(sortByName),
    title: 'JSON-RPC'
  });
}

/** @internal */
function addRuntime() {
  const sections = Object.keys(definitions).filter(key => Object.keys(definitions[key].runtime || {}).length !== 0);
  return renderPage({
    description: DESC_RUNTIME,
    sections: sections.sort().reduce((all, _sectionName) => {
      Object.entries(definitions[_sectionName].runtime || {}).forEach(_ref3 => {
        let [apiName, [{
          methods
        }]] = _ref3;
        const container = {
          items: [],
          name: apiName
        };
        all.push(container);
        Object.entries(methods).sort((_ref4, _ref5) => {
          let [a] = _ref4;
          let [b] = _ref5;
          return a.localeCompare(b);
        }).forEach(_ref6 => {
          let [methodName, {
            description,
            params,
            type
          }] = _ref6;
          const args = params.map(_ref7 => {
            let {
              name,
              type
            } = _ref7;
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            return name + ': `' + type + '`';
          }).join(', ');
          container.items.push({
            interface: '`' + `api.call.${(0, _util.stringCamelCase)(apiName)}.${(0, _util.stringCamelCase)(methodName)}` + '`',
            name: `${(0, _util.stringCamelCase)(methodName)}(${args}): ${'`' + type + '`'}`,
            runtime: '`' + `${apiName}_${methodName}` + '`',
            summary: description
          });
        });
      });
      return all;
    }, []).sort(sortByName),
    title: 'Runtime'
  });
}

/** @internal */
function addConstants(_ref8) {
  let {
    lookup,
    pallets
  } = _ref8;
  return renderPage({
    description: DESC_CONSTANTS,
    sections: pallets.sort(sortByName).filter(_ref9 => {
      let {
        constants
      } = _ref9;
      return !constants.isEmpty;
    }).map(_ref10 => {
      let {
        constants,
        name
      } = _ref10;
      const sectionName = (0, _util.stringLowerFirst)(name);
      return {
        items: constants.sort(sortByName).map(_ref11 => {
          let {
            docs,
            name,
            type
          } = _ref11;
          const methodName = (0, _util.stringCamelCase)(name);
          return {
            interface: '`' + `api.consts.${sectionName}.${methodName}` + '`',
            name: `${methodName}: ` + '`' + getSiName(lookup, type) + '`',
            ...(docs.length && {
              summary: docs
            })
          };
        }),
        name: sectionName
      };
    }),
    title: 'Constants'
  });
}

/** @internal */
function addStorage(_ref12) {
  let {
    lookup,
    pallets,
    registry
  } = _ref12;
  const {
    substrate
  } = (0, _getStorage.getStorage)(registry);
  const moduleSections = pallets.sort(sortByName).filter(moduleMetadata => !moduleMetadata.storage.isNone).map(moduleMetadata => {
    const sectionName = (0, _util.stringLowerFirst)(moduleMetadata.name);
    return {
      items: moduleMetadata.storage.unwrap().items.sort(sortByName).map(func => {
        let arg = '';
        if (func.type.isMap) {
          const {
            hashers,
            key
          } = func.type.asMap;
          arg = '`' + (hashers.length === 1 ? getSiName(lookup, key) : lookup.getSiType(key).def.asTuple.map(t => getSiName(lookup, t)).join(', ')) + '`';
        }
        const methodName = (0, _util.stringLowerFirst)(func.name);
        const outputType = (0, _StorageKey.unwrapStorageType)(registry, func.type, func.modifier.isOptional);
        return {
          interface: '`' + `api.query.${sectionName}.${methodName}` + '`',
          name: `${methodName}(${arg}): ` + '`' + outputType + '`',
          ...(func.docs.length && {
            summary: func.docs
          })
        };
      }),
      name: sectionName
    };
  });
  return renderPage({
    description: DESC_STORAGE,
    sections: moduleSections.concat([{
      description: 'These are well-known keys that are always available to the runtime implementation of any Substrate-based network.',
      items: Object.entries(substrate).map(_ref13 => {
        let [name, {
          meta
        }] = _ref13;
        const arg = meta.type.isMap ? '`' + getSiName(lookup, meta.type.asMap.key) + '`' : '';
        const methodName = (0, _util.stringLowerFirst)(name);
        const outputType = (0, _StorageKey.unwrapStorageType)(registry, meta.type, meta.modifier.isOptional);
        return {
          interface: '`' + `api.query.substrate.${methodName}` + '`',
          name: `${methodName}(${arg}): ` + '`' + outputType + '`',
          summary: meta.docs
        };
      }),
      name: 'substrate'
    }]).sort(sortByName),
    title: 'Storage'
  });
}

/** @internal */
function addExtrinsics(_ref14) {
  let {
    lookup,
    pallets
  } = _ref14;
  return renderPage({
    description: DESC_EXTRINSICS,
    sections: pallets.sort(sortByName).filter(_ref15 => {
      let {
        calls
      } = _ref15;
      return calls.isSome;
    }).map(_ref16 => {
      let {
        calls,
        name
      } = _ref16;
      const sectionName = (0, _util.stringCamelCase)(name);
      return {
        items: lookup.getSiType(calls.unwrap().type).def.asVariant.variants.sort(sortByName).map((_ref17, index) => {
          let {
            docs,
            fields,
            name
          } = _ref17;
          const methodName = (0, _util.stringCamelCase)(name);
          const args = fields.map(_ref18 => {
            let {
              name,
              type
            } = _ref18;
            return `${name.isSome ? name.toString() : `param${index}`}: ` + '`' + getSiName(lookup, type) + '`';
          }).join(', ');
          return {
            interface: '`' + `api.tx.${sectionName}.${methodName}` + '`',
            name: `${methodName}(${args})`,
            ...(docs.length && {
              summary: docs
            })
          };
        }),
        name: sectionName
      };
    }),
    title: 'Extrinsics'
  });
}

/** @internal */
function addEvents(_ref19) {
  let {
    lookup,
    pallets
  } = _ref19;
  return renderPage({
    description: DESC_EVENTS,
    sections: pallets.sort(sortByName).filter(_ref20 => {
      let {
        events
      } = _ref20;
      return events.isSome;
    }).map(meta => ({
      items: lookup.getSiType(meta.events.unwrap().type).def.asVariant.variants.sort(sortByName).map(_ref21 => {
        let {
          docs,
          fields,
          name
        } = _ref21;
        const methodName = name.toString();
        const args = fields.map(_ref22 => {
          let {
            type
          } = _ref22;
          return '`' + getSiName(lookup, type) + '`';
        }).join(', ');
        return {
          interface: '`' + `api.events.${(0, _util.stringCamelCase)(meta.name)}.${methodName}.is` + '`',
          name: `${methodName}(${args})`,
          ...(docs.length && {
            summary: docs
          })
        };
      }),
      name: (0, _util.stringCamelCase)(meta.name)
    })),
    title: 'Events'
  });
}

/** @internal */
function addErrors(_ref23) {
  let {
    lookup,
    pallets
  } = _ref23;
  return renderPage({
    description: DESC_ERRORS,
    sections: pallets.sort(sortByName).filter(_ref24 => {
      let {
        errors
      } = _ref24;
      return errors.isSome;
    }).map(moduleMetadata => ({
      items: lookup.getSiType(moduleMetadata.errors.unwrap().type).def.asVariant.variants.sort(sortByName).map(error => ({
        interface: '`' + `api.errors.${(0, _util.stringCamelCase)(moduleMetadata.name)}.${error.name.toString()}.is` + '`',
        name: error.name.toString(),
        ...(error.docs.length && {
          summary: error.docs
        })
      })),
      name: (0, _util.stringLowerFirst)(moduleMetadata.name)
    })),
    title: 'Errors'
  });
}

/** @internal */
function writeFile(name) {
  const writeStream = _fs.default.createWriteStream(name, {
    encoding: 'utf8',
    flags: 'w'
  });
  writeStream.on('finish', () => {
    console.log(`Completed writing ${name}`);
  });
  for (var _len = arguments.length, chunks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    chunks[_key - 1] = arguments[_key];
  }
  chunks.forEach(chunk => {
    writeStream.write(chunk);
  });
  writeStream.end();
}
function main() {
  const registry = new _types.TypeRegistry();
  const metadata = new _types.Metadata(registry, _staticSubstrate.default);
  registry.setMetadata(metadata);
  const latest = metadata.asLatest;
  writeFile('docs/substrate/rpc.md', addRpc());
  writeFile('docs/substrate/runtime.md', addRuntime());
  writeFile('docs/substrate/constants.md', addConstants(latest));
  writeFile('docs/substrate/storage.md', addStorage(latest));
  writeFile('docs/substrate/extrinsics.md', addExtrinsics(latest));
  writeFile('docs/substrate/events.md', addEvents(latest));
  writeFile('docs/substrate/errors.md', addErrors(latest));
}